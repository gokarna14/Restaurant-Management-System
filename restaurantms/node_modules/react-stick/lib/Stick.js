"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

require("requestidlecallback");

var _invariant = _interopRequireDefault(require("invariant"));

var _react = _interopRequireWildcard(require("react"));

var _substyle = _interopRequireDefault(require("substyle"));

var _StickContext = require("./StickContext");

var _StickInline = _interopRequireDefault(require("./StickInline"));

var _StickNode = _interopRequireDefault(require("./StickNode"));

var _StickPortal = _interopRequireDefault(require("./StickPortal"));

var _defaultPosition = _interopRequireDefault(require("./defaultPosition"));

var _hooks = require("./hooks");

var _utils = require("./utils");

var defaultStyles = {
  node: {
    position: 'absolute',
    zIndex: 99,
    textAlign: 'left'
  }
};

function Stick(_ref) {
  var _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      node = _ref.node,
      _ref$sameWidth = _ref.sameWidth,
      sameWidth = _ref$sameWidth === void 0 ? false : _ref$sameWidth,
      children = _ref.children,
      _ref$updateOnAnimatio = _ref.updateOnAnimationFrame,
      updateOnAnimationFrame = _ref$updateOnAnimatio === void 0 ? false : _ref$updateOnAnimatio,
      position = _ref.position,
      align = _ref.align,
      component = _ref.component,
      transportTo = _ref.transportTo,
      _ref$autoFlipHorizont = _ref.autoFlipHorizontally,
      autoFlipHorizontally = _ref$autoFlipHorizont === void 0 ? false : _ref$autoFlipHorizont,
      _ref$autoFlipVertical = _ref.autoFlipVertically,
      autoFlipVertically = _ref$autoFlipVertical === void 0 ? false : _ref$autoFlipVertical,
      onClickOutside = _ref.onClickOutside,
      style = _ref.style,
      className = _ref.className,
      classNames = _ref.classNames,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["inline", "node", "sameWidth", "children", "updateOnAnimationFrame", "position", "align", "component", "transportTo", "autoFlipHorizontally", "autoFlipVertically", "onClickOutside", "style", "className", "classNames"]);

  var _useState = (0, _react.useState)(0),
      width = _useState[0],
      setWidth = _useState[1];

  var _useState2 = (0, _react.useState)(function () {
    return (0, _utils.uniqueId)();
  }),
      containerNestingKeyExtension = _useState2[0];

  var nestingKey = [(0, _react.useContext)(_StickContext.StickContext), containerNestingKeyExtension].filter(function (key) {
    return !!key;
  }).join('_');
  var anchorRef = (0, _react.useRef)();
  var nodeRef = (0, _react.useRef)();

  var _containerRef = (0, _react.useRef)();

  var _useAutoFlip = (0, _hooks.useAutoFlip)(autoFlipHorizontally, autoFlipVertically, position || _defaultPosition.default, align || (0, _utils.getDefaultAlign)(position || _defaultPosition.default)),
      resolvedPosition = _useAutoFlip[0],
      resolvedAlign = _useAutoFlip[1],
      checkAlignment = _useAutoFlip[2];

  var styles = (0, _substyle.default)(defaultStyles, {
    style: style,
    className: className,
    classNames: classNames
  }, (0, _utils.getModifiers)({
    position: resolvedPosition,
    align: resolvedAlign,
    sameWidth: sameWidth
  }));
  (0, _react.useEffect)(function () {
    var handleScroll = function handleScroll() {
      if (!nodeRef.current || !anchorRef.current) {
        return;
      }

      checkAlignment(nodeRef.current, anchorRef.current);
    };

    handleScroll(); // Check alignment on first render

    window.addEventListener('scroll', handleScroll);
    return function () {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [checkAlignment]);
  (0, _react.useEffect)(function () {
    var handleClickOutside = function handleClickOutside(ev) {
      if (!onClickOutside) {
        return;
      }

      var target = ev.target;

      if (target instanceof window.HTMLElement && isOutside(anchorRef, _containerRef, target)) {
        onClickOutside(ev);
      }
    };

    document.addEventListener('click', handleClickOutside, true);
    return function () {
      document.removeEventListener('click', handleClickOutside, true);
    };
  }, [onClickOutside]);
  var measure = (0, _react.useCallback)(function () {
    if (!anchorRef.current) {
      return;
    }

    var boundingRect = anchorRef.current.getBoundingClientRect();
    var newWidth = sameWidth ? boundingRect.width : calculateWidth(anchorRef.current, resolvedPosition, resolvedAlign, boundingRect);

    if (newWidth !== width) {
      setWidth(newWidth);
    }
  }, [resolvedAlign, resolvedPosition, sameWidth, width]);
  (0, _hooks.useWatcher)(measure, {
    updateOnAnimationFrame: updateOnAnimationFrame,
    enabled: !!node
  });
  var handleReposition = (0, _react.useCallback)(function () {
    if (nodeRef.current && anchorRef.current) {
      checkAlignment(nodeRef.current, anchorRef.current);
    }
  }, [checkAlignment]);

  if (inline) {
    return /*#__PURE__*/_react.default.createElement(_StickContext.StickContext.Provider, {
      value: nestingKey
    }, /*#__PURE__*/_react.default.createElement(_StickInline.default, (0, _extends2.default)({}, rest, {
      position: resolvedPosition,
      align: resolvedAlign,
      style: styles,
      node: node && /*#__PURE__*/_react.default.createElement(_StickNode.default, {
        width: width,
        position: resolvedPosition,
        align: resolvedAlign,
        sameWidth: sameWidth,
        ref: nodeRef
      }, node),
      nestingKey: nestingKey,
      containerRef: function containerRef(node) {
        anchorRef.current = node;
        _containerRef.current = node;
      },
      component: component
    }), children));
  }

  return /*#__PURE__*/_react.default.createElement(_StickContext.StickContext.Provider, {
    value: nestingKey
  }, /*#__PURE__*/_react.default.createElement(_StickPortal.default, (0, _extends2.default)({}, rest, {
    updateOnAnimationFrame: updateOnAnimationFrame,
    transportTo: transportTo,
    component: component,
    ref: function ref(node) {
      (0, _invariant.default)(!node || node instanceof Element, 'Only HTML elements can be stick anchors.');
      anchorRef.current = node;
    },
    position: resolvedPosition,
    node: node && /*#__PURE__*/_react.default.createElement(_StickNode.default, {
      width: width,
      position: resolvedPosition,
      align: resolvedAlign,
      sameWidth: sameWidth,
      ref: nodeRef
    }, node),
    style: styles,
    nestingKey: nestingKey,
    containerRef: _containerRef,
    onReposition: handleReposition
  }), children));
}

function isOutside(anchorRef, containerRef, target) {
  if (anchorRef.current && anchorRef.current.contains(target)) {
    return false;
  }

  var nestingKey = containerRef.current && containerRef.current.getAttribute('data-sticknestingkey');

  if (nestingKey) {
    // Find all stick nodes nested inside our own stick node and check if the click
    // happened on any of these (our own stick node will also be part of the query result)
    var nestedStickNodes = document.querySelectorAll("[data-stickNestingKey^='" + nestingKey + "']");
    return !nestedStickNodes || !Array.from(nestedStickNodes).some(function (stickNode) {
      return stickNode.contains(target);
    });
  }

  return true;
}

function calculateWidth(anchorRef, position, align, _ref2) {
  var left = _ref2.left,
      width = _ref2.width,
      right = _ref2.right;

  if (!anchorRef) {
    return 0;
  }

  (0, _invariant.default)(document.documentElement, 'Could not find document root node.');
  var scrollWidth = document.documentElement.scrollWidth;

  var _position$split = position.split(' '),
      horizontalPosition = _position$split[1];

  (0, _invariant.default)(horizontalPosition === 'left' || horizontalPosition === 'center' || horizontalPosition === 'right', "Expected horizontal position to be \"left\", \"center\", or \"right\" but got \"" + horizontalPosition + "\".");
  var positionAdjustments = {
    left: left,
    center: left + width / 2,
    right: right
  };
  var absLeft = (0, _utils.scrollX)(anchorRef) + positionAdjustments[horizontalPosition];

  if (align.indexOf('left') !== -1) {
    return scrollWidth - absLeft;
  }

  if (align.indexOf('right') !== -1) {
    return absLeft;
  }

  if (align.indexOf('center') !== -1) {
    return Math.min(absLeft, scrollWidth - absLeft) * 2;
  }

  return 0;
}

var _default = Stick;
exports.default = _default;
module.exports = exports.default;