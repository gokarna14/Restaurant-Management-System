import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import 'requestidlecallback';
import invariant from 'invariant';
import React, { createContext, forwardRef, useCallback, useContext, useEffect, useLayoutEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { inline } from 'substyle';
import { useWatcher } from './hooks';
import { scrollX, scrollY } from './utils';

function StickPortal(_ref, _ref2) {
  var children = _ref.children,
      component = _ref.component,
      style = _ref.style,
      transportTo = _ref.transportTo,
      nestingKey = _ref.nestingKey,
      node = _ref.node,
      position = _ref.position,
      containerRef = _ref.containerRef,
      updateOnAnimationFrame = _ref.updateOnAnimationFrame,
      onReposition = _ref.onReposition,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "component", "style", "transportTo", "nestingKey", "node", "position", "containerRef", "updateOnAnimationFrame", "onReposition"]);

  var nodeRef = useRef();

  var _useState = useState(null),
      top = _useState[0],
      setTop = _useState[1];

  var _useState2 = useState(null),
      left = _useState2[0],
      setLeft = _useState2[1];

  var _useState3 = useState(!!node),
      visible = _useState3[0],
      setVisible = _useState3[1];

  var _useHost = useHost(transportTo),
      host = _useHost[0],
      hostParent = _useHost[1];

  useEffect(function () {
    if (nodeRef.current) {
      onReposition(nodeRef.current);
    }
  }, [onReposition, top, left]);
  useEffect(function () {
    setVisible(!!node);
  }, [node]);
  useLayoutEffect(function () {
    if (visible) {
      hostParent.appendChild(host);
      return function () {
        hostParent.removeChild(host);
      };
    }
  }, [host, hostParent, visible]);
  var measure = useCallback(function () {
    var node = nodeRef.current;

    if (!node || !visible) {
      return;
    }

    var newTop = calculateTop(node, position, host);
    var newLeft = calculateLeft(node, position, host);

    if (newTop !== top) {
      setTop(newTop);
    }

    if (newLeft !== left) {
      setLeft(newLeft);
    }
  }, [host, left, position, top, visible]);
  useWatcher(measure, {
    updateOnAnimationFrame: updateOnAnimationFrame,
    enabled: visible
  });
  var Component = component || 'div';
  return /*#__PURE__*/React.createElement(Component, _extends({}, rest, style, {
    ref: function ref(node) {
      if (typeof _ref2 === 'function') {
        _ref2(node);
      } else {
        _ref2.current = node;
      }

      nodeRef.current = node;
    }
  }), children, top != null && left != null && /*#__PURE__*/React.createElement(PortalContext.Provider, {
    value: host.parentNode || defaultRoot
  }, /*#__PURE__*/createPortal( /*#__PURE__*/React.createElement("div", _extends({
    ref: containerRef,
    "data-sticknestingkey": nestingKey
  }, inline(style('node'), {
    position: 'absolute',
    top: top,
    left: left
  })), node), host)));
}

invariant(document.body, 'Stick can only be used in a browser environment.');
var defaultRoot = document.body;
export var PortalContext = /*#__PURE__*/createContext(defaultRoot);
export default /*#__PURE__*/forwardRef(StickPortal);

function useHost(transportTo) {
  var _useState4 = useState(function () {
    return document.createElement('div');
  }),
      host = _useState4[0];

  var portalHost = useContext(PortalContext);
  var hostParent = transportTo || portalHost;
  invariant(hostParent, 'Could not determine a parent for the host node.');
  return [host, hostParent];
}

function calculateTop(node, position, host) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
      top = _node$getBoundingClie.top,
      height = _node$getBoundingClie.height,
      bottom = _node$getBoundingClie.bottom;

  var fixedHost = getFixedParent(host);
  var result = 0;

  if (position.indexOf('top') !== -1) {
    result = top;
  }

  if (position.indexOf('middle') !== -1) {
    result = top + height / 2;
  }

  if (position.indexOf('bottom') !== -1) {
    result = bottom;
  }

  if (fixedHost) {
    var _fixedHost$getBoundin = fixedHost.getBoundingClientRect(),
        hostTop = _fixedHost$getBoundin.top;

    return result - hostTop;
  }

  return result + scrollY();
}

function calculateLeft(node, position, host) {
  var _node$getBoundingClie2 = node.getBoundingClientRect(),
      left = _node$getBoundingClie2.left,
      width = _node$getBoundingClie2.width,
      right = _node$getBoundingClie2.right;

  var fixedHost = getFixedParent(host);
  var scrollHost = getScrollParent(node);
  var result = 0;

  if (position.indexOf('left') !== -1) {
    result = left;
  }

  if (position.indexOf('center') !== -1) {
    result = left + width / 2;
  }

  if (position.indexOf('right') !== -1) {
    result = right;
  }

  if (fixedHost) {
    var _fixedHost$getBoundin2 = fixedHost.getBoundingClientRect(),
        hostLeft = _fixedHost$getBoundin2.left;

    return result - hostLeft;
  }

  if (scrollHost) {
    return result + scrollX(node) - scrollHost.scrollLeft;
  }

  return result + scrollX(node);
}

function getScrollParent(element) {
  if (!element) {
    return null;
  }

  if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {
    return null;
  }

  var style = getComputedStyle(element);

  if (style.overflowX === 'auto' || style.overflowX === 'scroll') {
    return element;
  }

  return element.parentNode instanceof Element ? getScrollParent(element.parentNode) : null;
}

function getFixedParent(element) {
  if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {
    return null;
  }

  if (getComputedStyle(element).position === 'fixed') {
    return element;
  }

  return element.parentNode instanceof Element ? getFixedParent(element.parentNode) : null;
}