import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import 'requestidlecallback';
import invariant from 'invariant';
import React, { useCallback, useContext, useEffect, useRef, useState } from 'react';
import useStyles from 'substyle';
import { StickContext } from './StickContext';
import StickInline from './StickInline';
import StickNode from './StickNode';
import StickPortal from './StickPortal';
import DEFAULT_POSITION from './defaultPosition';
import { useAutoFlip, useWatcher } from './hooks';
import { getDefaultAlign, getModifiers, scrollX, uniqueId } from './utils';
var defaultStyles = {
  node: {
    position: 'absolute',
    zIndex: 99,
    textAlign: 'left'
  }
};

function Stick(_ref) {
  var _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      node = _ref.node,
      _ref$sameWidth = _ref.sameWidth,
      sameWidth = _ref$sameWidth === void 0 ? false : _ref$sameWidth,
      children = _ref.children,
      _ref$updateOnAnimatio = _ref.updateOnAnimationFrame,
      updateOnAnimationFrame = _ref$updateOnAnimatio === void 0 ? false : _ref$updateOnAnimatio,
      position = _ref.position,
      align = _ref.align,
      component = _ref.component,
      transportTo = _ref.transportTo,
      _ref$autoFlipHorizont = _ref.autoFlipHorizontally,
      autoFlipHorizontally = _ref$autoFlipHorizont === void 0 ? false : _ref$autoFlipHorizont,
      _ref$autoFlipVertical = _ref.autoFlipVertically,
      autoFlipVertically = _ref$autoFlipVertical === void 0 ? false : _ref$autoFlipVertical,
      onClickOutside = _ref.onClickOutside,
      style = _ref.style,
      className = _ref.className,
      classNames = _ref.classNames,
      rest = _objectWithoutPropertiesLoose(_ref, ["inline", "node", "sameWidth", "children", "updateOnAnimationFrame", "position", "align", "component", "transportTo", "autoFlipHorizontally", "autoFlipVertically", "onClickOutside", "style", "className", "classNames"]);

  var _useState = useState(0),
      width = _useState[0],
      setWidth = _useState[1];

  var _useState2 = useState(function () {
    return uniqueId();
  }),
      containerNestingKeyExtension = _useState2[0];

  var nestingKey = [useContext(StickContext), containerNestingKeyExtension].filter(function (key) {
    return !!key;
  }).join('_');
  var anchorRef = useRef();
  var nodeRef = useRef();

  var _containerRef = useRef();

  var _useAutoFlip = useAutoFlip(autoFlipHorizontally, autoFlipVertically, position || DEFAULT_POSITION, align || getDefaultAlign(position || DEFAULT_POSITION)),
      resolvedPosition = _useAutoFlip[0],
      resolvedAlign = _useAutoFlip[1],
      checkAlignment = _useAutoFlip[2];

  var styles = useStyles(defaultStyles, {
    style: style,
    className: className,
    classNames: classNames
  }, getModifiers({
    position: resolvedPosition,
    align: resolvedAlign,
    sameWidth: sameWidth
  }));
  useEffect(function () {
    var handleScroll = function handleScroll() {
      if (!nodeRef.current || !anchorRef.current) {
        return;
      }

      checkAlignment(nodeRef.current, anchorRef.current);
    };

    handleScroll(); // Check alignment on first render

    window.addEventListener('scroll', handleScroll);
    return function () {
      window.removeEventListener('scroll', handleScroll);
    };
  }, [checkAlignment]);
  useEffect(function () {
    var handleClickOutside = function handleClickOutside(ev) {
      if (!onClickOutside) {
        return;
      }

      var target = ev.target;

      if (target instanceof window.HTMLElement && isOutside(anchorRef, _containerRef, target)) {
        onClickOutside(ev);
      }
    };

    document.addEventListener('click', handleClickOutside, true);
    return function () {
      document.removeEventListener('click', handleClickOutside, true);
    };
  }, [onClickOutside]);
  var measure = useCallback(function () {
    if (!anchorRef.current) {
      return;
    }

    var boundingRect = anchorRef.current.getBoundingClientRect();
    var newWidth = sameWidth ? boundingRect.width : calculateWidth(anchorRef.current, resolvedPosition, resolvedAlign, boundingRect);

    if (newWidth !== width) {
      setWidth(newWidth);
    }
  }, [resolvedAlign, resolvedPosition, sameWidth, width]);
  useWatcher(measure, {
    updateOnAnimationFrame: updateOnAnimationFrame,
    enabled: !!node
  });
  var handleReposition = useCallback(function () {
    if (nodeRef.current && anchorRef.current) {
      checkAlignment(nodeRef.current, anchorRef.current);
    }
  }, [checkAlignment]);

  if (inline) {
    return /*#__PURE__*/React.createElement(StickContext.Provider, {
      value: nestingKey
    }, /*#__PURE__*/React.createElement(StickInline, _extends({}, rest, {
      position: resolvedPosition,
      align: resolvedAlign,
      style: styles,
      node: node && /*#__PURE__*/React.createElement(StickNode, {
        width: width,
        position: resolvedPosition,
        align: resolvedAlign,
        sameWidth: sameWidth,
        ref: nodeRef
      }, node),
      nestingKey: nestingKey,
      containerRef: function containerRef(node) {
        anchorRef.current = node;
        _containerRef.current = node;
      },
      component: component
    }), children));
  }

  return /*#__PURE__*/React.createElement(StickContext.Provider, {
    value: nestingKey
  }, /*#__PURE__*/React.createElement(StickPortal, _extends({}, rest, {
    updateOnAnimationFrame: updateOnAnimationFrame,
    transportTo: transportTo,
    component: component,
    ref: function ref(node) {
      invariant(!node || node instanceof Element, 'Only HTML elements can be stick anchors.');
      anchorRef.current = node;
    },
    position: resolvedPosition,
    node: node && /*#__PURE__*/React.createElement(StickNode, {
      width: width,
      position: resolvedPosition,
      align: resolvedAlign,
      sameWidth: sameWidth,
      ref: nodeRef
    }, node),
    style: styles,
    nestingKey: nestingKey,
    containerRef: _containerRef,
    onReposition: handleReposition
  }), children));
}

function isOutside(anchorRef, containerRef, target) {
  if (anchorRef.current && anchorRef.current.contains(target)) {
    return false;
  }

  var nestingKey = containerRef.current && containerRef.current.getAttribute('data-sticknestingkey');

  if (nestingKey) {
    // Find all stick nodes nested inside our own stick node and check if the click
    // happened on any of these (our own stick node will also be part of the query result)
    var nestedStickNodes = document.querySelectorAll("[data-stickNestingKey^='" + nestingKey + "']");
    return !nestedStickNodes || !Array.from(nestedStickNodes).some(function (stickNode) {
      return stickNode.contains(target);
    });
  }

  return true;
}

function calculateWidth(anchorRef, position, align, _ref2) {
  var left = _ref2.left,
      width = _ref2.width,
      right = _ref2.right;

  if (!anchorRef) {
    return 0;
  }

  invariant(document.documentElement, 'Could not find document root node.');
  var scrollWidth = document.documentElement.scrollWidth;

  var _position$split = position.split(' '),
      horizontalPosition = _position$split[1];

  invariant(horizontalPosition === 'left' || horizontalPosition === 'center' || horizontalPosition === 'right', "Expected horizontal position to be \"left\", \"center\", or \"right\" but got \"" + horizontalPosition + "\".");
  var positionAdjustments = {
    left: left,
    center: left + width / 2,
    right: right
  };
  var absLeft = scrollX(anchorRef) + positionAdjustments[horizontalPosition];

  if (align.indexOf('left') !== -1) {
    return scrollWidth - absLeft;
  }

  if (align.indexOf('right') !== -1) {
    return absLeft;
  }

  if (align.indexOf('center') !== -1) {
    return Math.min(absLeft, scrollWidth - absLeft) * 2;
  }

  return 0;
}

export default Stick;